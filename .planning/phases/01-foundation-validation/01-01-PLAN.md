---
phase: 01-foundation-validation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/tests/__init__.py
  - backend/tests/test_schema.py
  - backend/tests/test_state.py
  - backend/tests/conftest.py
autonomous: true

must_haves:
  truths:
    - "Schema validation accepts valid classification data"
    - "Schema validation rejects invalid destinations"
    - "State module tracks processed messages correctly"
    - "Filename sanitization handles edge cases"
  artifacts:
    - path: "backend/tests/test_schema.py"
      provides: "Unit tests for schema validation"
      min_lines: 50
    - path: "backend/tests/test_state.py"
      provides: "Unit tests for state management"
      min_lines: 40
  key_links:
    - from: "backend/tests/test_schema.py"
      to: "backend/_scripts/schema.py"
      via: "import"
      pattern: "from schema import"
    - from: "backend/tests/test_state.py"
      to: "backend/_scripts/state.py"
      via: "import"
      pattern: "from state import"
---

<objective>
Validate that core backend modules (schema validation, state management) work correctly through unit tests.

Purpose: These modules are pure functions with no external dependencies - perfect for fast, reliable unit testing. Validates Success Criteria #4 (state tracking) and foundational code quality.

Output: Test suite for schema.py and state.py that can run offline with `uv run pytest`.
</objective>

<execution_context>
@/Users/richardyu/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardyu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@backend/_scripts/schema.py
@backend/_scripts/state.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test infrastructure</name>
  <files>
    backend/tests/__init__.py
    backend/tests/conftest.py
  </files>
  <action>
    Create backend/tests/ directory structure:

    1. Create backend/tests/__init__.py (empty file)

    2. Create backend/tests/conftest.py with:
       - Fixture for temporary state directory (use tmp_path)
       - Fixture to add _scripts to sys.path for imports
       - Fixture for sample classification data

    Use pytest's tmp_path fixture to isolate state tests from real state files.

    Ensure the conftest adds backend/_scripts to sys.path so tests can import schema, state modules.
  </action>
  <verify>
    cd /Users/richardyu/PARA/Personal/1_Projects/apps/second-brain/backend && uv run python -c "import sys; sys.path.insert(0, '_scripts'); from schema import validate_classification; print('imports work')"
  </verify>
  <done>
    Test infrastructure created, imports from _scripts work in test context.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write schema validation tests</name>
  <files>backend/tests/test_schema.py</files>
  <action>
    Create comprehensive tests for schema.py:

    Test validate_classification():
    - Valid classification with all fields returns cleaned data
    - Missing confidence defaults to 0.5
    - Invalid destination raises ValidationError
    - Confidence outside 0-1 gets clamped
    - Missing filename generates fallback
    - Empty extracted becomes empty dict

    Test sanitize_filename():
    - Converts spaces and underscores to hyphens
    - Removes path traversal attempts (../, /, \)
    - Handles unicode and special characters
    - Truncates at 100 characters
    - Empty input returns "untitled"

    Test validate_linked_entity():
    - Valid person entity returns normalized
    - Valid project entity returns normalized
    - Missing name returns None
    - Unknown type returns None

    Test create_fallback_classification():
    - Returns "ideas" with low confidence
    - Includes error in extracted metadata

    Use pytest parametrize for edge cases where appropriate.
  </action>
  <verify>
    cd /Users/richardyu/PARA/Personal/1_Projects/apps/second-brain/backend && uv run pytest tests/test_schema.py -v
  </verify>
  <done>
    All schema tests pass. Tests cover valid input, invalid input, edge cases, and error handling.
  </done>
</task>

<task type="auto">
  <name>Task 3: Write state management tests</name>
  <files>backend/tests/test_state.py</files>
  <action>
    Create tests for state.py using tmp_path to isolate from real state:

    Test message processing idempotency:
    - mark_message_processed() then is_message_processed() returns True
    - is_message_processed() for unknown message returns False
    - Duplicate mark_message_processed() is idempotent (no error)

    Test message-to-file mapping:
    - set_file_for_message() then get_file_for_message() returns path
    - get_file_for_message() for unknown message returns None
    - update_file_location() changes the stored path
    - remove_message_mapping() clears the mapping

    Test cleanup_old_processed_messages():
    - Old entries (>30 days) are removed
    - Recent entries are preserved

    IMPORTANT: Monkeypatch STATE_DIR to use tmp_path so tests don't pollute real state files.

    Test atomic JSON operations:
    - Concurrent reads don't corrupt data
    - File locking works (basic smoke test)
  </action>
  <verify>
    cd /Users/richardyu/PARA/Personal/1_Projects/apps/second-brain/backend && uv run pytest tests/test_state.py -v
  </verify>
  <done>
    All state tests pass. Idempotency verified. State isolation confirmed via tmp_path.
  </done>
</task>

</tasks>

<verification>
Run full test suite:
```bash
cd /Users/richardyu/PARA/Personal/1_Projects/apps/second-brain/backend
uv run pytest tests/ -v --tb=short
```

Expected: All tests pass, no warnings about missing fixtures.
</verification>

<success_criteria>
1. backend/tests/ directory exists with __init__.py, conftest.py
2. test_schema.py has at least 8 test cases covering validation
3. test_state.py has at least 6 test cases covering idempotency
4. `uv run pytest tests/ -v` exits with code 0
5. No tests access real ~/.../state files (all use tmp_path)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-validation/01-01-SUMMARY.md`
</output>
