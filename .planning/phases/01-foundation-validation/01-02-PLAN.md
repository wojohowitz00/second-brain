---
phase: 01-foundation-validation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - backend/tests/test_slack_client.py
  - backend/tests/test_integration.py
autonomous: false
user_setup:
  - service: slack
    why: "Integration tests require real Slack API access"
    env_vars:
      - name: SLACK_BOT_TOKEN
        source: "api.slack.com > Your App > OAuth & Permissions > Bot User OAuth Token"
      - name: SLACK_CHANNEL_ID
        source: "Right-click #wry_sb channel > View channel details > scroll to bottom"
      - name: SLACK_USER_ID
        source: "Click your profile > ... > Copy member ID"

must_haves:
  truths:
    - "Backend can fetch messages from Slack channel"
    - "Backend can create .md files with frontmatter in test vault"
    - "Backend can process fix: corrections"
    - "State tracking correctly prevents duplicate processing"
  artifacts:
    - path: "backend/tests/test_slack_client.py"
      provides: "Integration tests for Slack API"
      min_lines: 40
    - path: "backend/tests/test_integration.py"
      provides: "End-to-end validation tests"
      min_lines: 60
  key_links:
    - from: "backend/tests/test_slack_client.py"
      to: "backend/_scripts/slack_client.py"
      via: "import"
      pattern: "from slack_client import"
    - from: "backend/tests/test_integration.py"
      to: "backend/_scripts/process_inbox.py"
      via: "import"
      pattern: "from process_inbox import"
---

<objective>
Validate all four phase success criteria through integration tests that touch real Slack API and file system.

Purpose: Phase 1 success requires proving the existing backend actually works. This plan validates:
1. Slack message fetching (Success Criteria #1)
2. .md file creation with frontmatter (Success Criteria #2)
3. fix: correction processing (Success Criteria #3)
4. State tracking idempotency (Success Criteria #4)

Output: Integration test suite that validates live backend capabilities.
</objective>

<execution_context>
@/Users/richardyu/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardyu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-validation/01-01-SUMMARY.md
@backend/_scripts/slack_client.py
@backend/_scripts/process_inbox.py
@backend/_scripts/fix_handler.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write Slack client integration tests</name>
  <files>backend/tests/test_slack_client.py</files>
  <action>
    Create integration tests for slack_client.py.

    These tests require real Slack credentials in environment.
    Mark with @pytest.mark.integration so they can be skipped when env vars missing.

    Test fetch_messages():
    - Returns list (may be empty if no recent messages)
    - Filters out bot messages
    - Respects oldest parameter

    Test fetch_thread_replies():
    - Returns list for valid thread
    - Handles non-existent thread gracefully

    Test error handling:
    - Missing SLACK_BOT_TOKEN raises ValueError
    - Invalid token raises SlackAPIError

    Add conftest fixture to check for SLACK_BOT_TOKEN and skip integration tests if missing:
    ```python
    @pytest.fixture
    def require_slack_env():
        if not os.environ.get("SLACK_BOT_TOKEN"):
            pytest.skip("SLACK_BOT_TOKEN not set - skipping integration test")
    ```

    DO NOT test post_message or reply_to_message (avoid spamming channel during tests).
  </action>
  <verify>
    # First, check env vars exist
    cd /Users/richardyu/PARA/Personal/1_Projects/apps/second-brain/backend
    source _scripts/.env 2>/dev/null || echo "No .env file"
    uv run pytest tests/test_slack_client.py -v -m integration || echo "Integration tests skipped (expected if no .env)"
  </verify>
  <done>
    Slack client tests created. Tests skip gracefully when credentials missing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write file creation and state integration tests</name>
  <files>backend/tests/test_integration.py</files>
  <action>
    Create integration tests that validate Success Criteria #2, #3, #4.

    Test .md file creation (Success Criteria #2):
    - write_to_obsidian() creates file in correct folder
    - File has valid YAML frontmatter (opens with ---, closes with ---)
    - Frontmatter includes required fields (type, created)
    - Original capture text appears in file
    - Use tmp_path as test vault, monkeypatch VAULT_PATH

    Test fix: correction flow (Success Criteria #3):
    - move_file() moves file to new destination
    - Frontmatter is updated with moved_from, moved_at
    - Original file no longer exists
    - Use tmp_path, create test file first

    Test state idempotency (Success Criteria #4):
    - Process message once, mark processed
    - Attempt to process same message again
    - Verify it's skipped (is_message_processed returns True)
    - Use tmp_path for state directory

    Structure tests to be runnable without Slack (mock fetch_messages where needed).
  </action>
  <verify>
    cd /Users/richardyu/PARA/Personal/1_Projects/apps/second-brain/backend && uv run pytest tests/test_integration.py -v
  </verify>
  <done>
    Integration tests pass. File creation, fix handling, and idempotency all verified.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Complete test suite validating all four Phase 1 success criteria:
    1. Slack message fetching (integration test with real Slack)
    2. .md file creation with frontmatter (isolated test)
    3. fix: correction processing (isolated test)
    4. State tracking idempotency (isolated test)
  </what-built>
  <how-to-verify>
    1. Ensure backend/_scripts/.env exists with your Slack credentials:
       ```bash
       cat backend/_scripts/.env
       ```
       Should show SLACK_BOT_TOKEN, SLACK_CHANNEL_ID, SLACK_USER_ID (not placeholder values)

    2. Run the full test suite:
       ```bash
       cd /Users/richardyu/PARA/Personal/1_Projects/apps/second-brain/backend
       source _scripts/.env
       uv run pytest tests/ -v
       ```

    3. Verify all tests pass:
       - test_schema.py: All pass (unit tests)
       - test_state.py: All pass (unit tests)
       - test_slack_client.py: Pass or skip (integration)
       - test_integration.py: All pass

    4. If integration tests fail with "not_in_channel", invite your bot:
       `/invite @SecondBrain` in #wry_sb

    5. Confirm output shows SUCCESS CRITERIA MET:
       - Slack fetch works (or gracefully skipped)
       - File creation works
       - Fix handling works
       - Idempotency works
  </how-to-verify>
  <resume-signal>Type "approved" if all success criteria verified, or describe issues found</resume-signal>
</task>

</tasks>

<verification>
Run full test suite with integration tests:
```bash
cd /Users/richardyu/PARA/Personal/1_Projects/apps/second-brain/backend
source _scripts/.env
uv run pytest tests/ -v --tb=short
```

Expected output:
- All unit tests pass
- Integration tests pass (or skip if no env)
- No import errors
- No file system pollution (all uses tmp_path)

Phase 1 Success Criteria checklist:
- [ ] Backend can fetch messages from Slack channel (test_slack_client.py)
- [ ] Backend can create .md files with frontmatter in test vault (test_integration.py)
- [ ] Backend can process fix: corrections (test_integration.py)
- [ ] State tracking correctly prevents duplicate processing (test_state.py, test_integration.py)
</verification>

<success_criteria>
1. test_slack_client.py exists with integration tests
2. test_integration.py exists with file/fix/state tests
3. `uv run pytest tests/ -v` exits 0 (all pass or intentionally skipped)
4. Human verification confirms Slack works with real credentials
5. All four phase success criteria have corresponding passing tests
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-validation/01-02-SUMMARY.md`
</output>
