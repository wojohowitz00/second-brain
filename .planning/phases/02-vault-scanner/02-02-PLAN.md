---
phase: 02-vault-scanner
plan: 02
type: tdd
wave: 2
depends_on: ["02-01"]
files_modified:
  - backend/_scripts/vault_scanner.py
  - backend/tests/test_vault_scanner.py
autonomous: true

must_haves:
  truths:
    - "Structure is cached to JSON file with timestamp"
    - "Cache expires after configurable TTL (default 6 hours)"
    - "Expired cache triggers fresh scan"
    - "Manual rescan bypasses cache"
    - "Cache is exposed as vocabulary for classification"
  artifacts:
    - path: "backend/_scripts/vault_scanner.py"
      provides: "VaultScanner with caching and vocabulary methods"
      exports: ["VaultScanner", "get_vault_structure", "rescan_vault", "get_vocabulary"]
    - path: "backend/_scripts/.state/vault_cache.json"
      provides: "Cached vault structure"
  key_links:
    - from: "backend/_scripts/vault_scanner.py"
      to: "backend/_scripts/.state/vault_cache.json"
      via: "atomic JSON write"
      pattern: "_atomic_json_write|json.dump"
---

<objective>
Add TTL-based caching and vocabulary extraction to the vault scanner. Cache persists across restarts and expires after 6 hours by default. Manual rescan function allows immediate refresh.

Purpose: Caching avoids rescanning the filesystem every time vocabulary is needed. Vocabulary extraction exposes the structure in a format ready for LLM classification prompts.

Output: VaultScanner with get_structure(force_refresh), manual_rescan(), and get_vocabulary() methods.
</objective>

<execution_context>
@/Users/richardyu/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardyu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-vault-scanner/02-RESEARCH.md
@.planning/phases/02-vault-scanner/02-01-SUMMARY.md
@backend/_scripts/state.py
@backend/_scripts/vault_scanner.py
</context>

<feature>
  <name>Cache Layer and Vocabulary</name>
  <files>
    backend/_scripts/vault_scanner.py
    backend/tests/test_vault_scanner.py
  </files>
  <behavior>
    Cache format in .state/vault_cache.json:
    {
        "structure": {...},
        "cached_at": "2026-01-31T10:30:00",
        "ttl_hours": 6,
        "version": 1
    }

    Test cases (TDD - write tests FIRST):

    1. No cache file exists -> scans and creates cache
    2. Valid cache (< TTL) -> returns cached structure without scanning
    3. Expired cache (> TTL) -> rescans and updates cache
    4. Corrupted cache JSON -> ignores cache, rescans
    5. Cache missing timestamp -> ignores cache, rescans
    6. force_refresh=True -> bypasses cache, rescans
    7. manual_rescan() -> same as force_refresh=True
    8. TTL boundary: exactly at TTL -> still valid (uses >=, not >)
    9. Custom TTL: ttl_hours=1 expires faster
    10. Cache persists across VaultScanner instances

    Vocabulary extraction tests:

    11. get_vocabulary() returns flat lists: domains, para_types, subjects
    12. Vocabulary includes all unique PARA names across domains
    13. Vocabulary includes all unique subjects across all PARA folders
    14. Vocabulary is sorted alphabetically
  </behavior>
  <implementation>
    Extend VaultScanner class with:

    1. Cache methods:
       - _load_cache() -> Optional[Dict] - returns None if expired/missing
       - _save_cache(structure: Dict) - atomic write with fcntl locking
       - get_structure(force_refresh: bool = False) -> Dict
       - manual_rescan() -> Dict

    2. Vocabulary methods:
       - get_vocabulary() -> Dict[str, List[str]]
         Returns: {
             "domains": ["CCBH", "Just Value", "Personal"],
             "para_types": ["1_Projects", "2_Areas", "3_Resources", "4_Archive"],
             "subjects": ["admin", "apps", "clients", "finance", ...]
         }

    3. Module constants:
       - CACHE_FILE = STATE_DIR / "vault_cache.json"
       - DEFAULT_TTL_HOURS = 6

    4. Convenience functions:
       - get_vault_structure(force_refresh=False) -> Dict
       - rescan_vault() -> Dict
       - get_vocabulary() -> Dict[str, List[str]]

    Reuse atomic JSON write pattern from state.py (fcntl locking, temp file, rename).
    Use datetime.fromisoformat() for timestamp parsing.
    Handle json.JSONDecodeError, KeyError, ValueError for corrupted cache.
  </implementation>
</feature>

<verification>
Run tests:
```bash
cd /Users/richardyu/PARA/Personal/1_Projects/apps/second-brain/backend
uv run pytest tests/test_vault_scanner.py -v --tb=short
```

Verify caching works:
```bash
cd /Users/richardyu/PARA/Personal/1_Projects/apps/second-brain/backend

# First call should scan
uv run python -c "from vault_scanner import get_vault_structure; print('Scanning...'); s = get_vault_structure(); print(f'Found {len(s)} domains')"

# Check cache file exists
cat _scripts/.state/vault_cache.json | head -5

# Second call should use cache (no scan)
uv run python -c "from vault_scanner import get_vault_structure; import time; start=time.time(); s = get_vault_structure(); print(f'Cached: {(time.time()-start)*1000:.1f}ms')"
```

Verify vocabulary extraction:
```bash
cd /Users/richardyu/PARA/Personal/1_Projects/apps/second-brain/backend
uv run python -c "from vault_scanner import get_vocabulary; import json; print(json.dumps(get_vocabulary(), indent=2))"
```
</verification>

<success_criteria>
1. Tests written FIRST, fail initially (RED phase)
2. get_structure() returns cached data when cache is valid
3. get_structure() rescans when cache is expired or missing
4. manual_rescan() always performs fresh scan
5. get_vocabulary() returns flat lists of domains, para_types, subjects
6. Cache file created at _scripts/.state/vault_cache.json
7. At least 14 test cases covering cache and vocabulary
8. Tests use tmp_path for cache file isolation
9. `uv run pytest tests/test_vault_scanner.py -v` exits with code 0
</success_criteria>

<output>
After completion, create `.planning/phases/02-vault-scanner/02-02-SUMMARY.md`
</output>
